#!/bin/bash
# fix_fasta_headers.sh
# Mostly generated by deepseek

if [ $# -ne 1 ]; then
    echo "Usage: $0 <input.fasta>"
    exit 1
fi

input="$1"
filename=$(basename "$input")
out_dir=$(dirname $PWD/$input)
mkdir -p $out_dir/cleanup
clean_output="$out_dir/${filename%.*}_clean.fasta"
removed_output="$out_dir/cleanup/${filename%.*}_removed.fasta"
logfile="$out_dir/cleanup/${filename%.*}_fix.log"

> "$clean_output"
> "$removed_output"

echo "Processing $filename..." | tee "$logfile"

# Process the FASTA file
awk -v removed="$removed_output" '
BEGIN {
    seq_buffer = ""
    in_removed = 0
}

/^>/ {
    # Process previous sequence if exists
    if (header != "") {
        if (in_removed) {
            # Save removed sequence
            print header "\n" seq_buffer >> removed
        } else {
            # Save cleaned sequence
            print header "\n" seq_buffer
        }
    }
    
    # Reset for new sequence
    header = $0
    seq_buffer = ""
    in_removed = 0
    
    # Count names (non-empty fields between semicolons)
    # First remove leading > and split by ;
    line = substr(header, 2)  # remove >
    n = split(line, fields, ";")
    
    # Count non-empty names
    name_count = 0
    for (i = 1; i <= n; i++) {
        if (fields[i] != "") name_count++
    }
    
    # Rule 3: Remove if fewer than 2 names
    if (name_count < 2) {
        in_removed = 1
        next  # Skip to next record, will be saved in removed file
    }
    
    # Count semicolons in entire header
    sc = gsub(/;/, ";", header)
    
    # Rule 2 & 1: Ensure exactly 6 semicolons
    if (sc > 6) {
        # This shouldnt happen normally, but trim to 6 if it does
        # Remove trailing semicolons beyond 6
        while (sc > 6) {
            sub(/;$/, "", header)
            sc--
        }
    } else if (sc < 6) {
        # Add missing semicolons
        while (sc < 6) {
            header = header ";"
            sc++
        }
    }
    next
}

# Sequence lines
{
    if (header == "") next  # safety
    # Append sequence lines, preserving line breaks
    if (seq_buffer == "") {
        seq_buffer = $0
    } else {
        seq_buffer = seq_buffer "\n" $0
    }
}

END {
    # Process last sequence
    if (header != "") {
        if (in_removed) {
            print header "\n" seq_buffer >> removed
        } else {
            print header "\n" seq_buffer
        }
    }
}
' "$input" > "$clean_output"

# Count results
total_headers=$(grep -c '^>' "$input")
clean_headers=$(grep -c '^>' "$clean_output")
removed_headers=$(grep -c '^>' "$removed_output" 2>/dev/null || echo 0)

echo "--- Summary ---" | tee -a "$logfile"
echo "Total headers: $total_headers" | tee -a "$logfile"
echo "Cleaned headers: $clean_headers" | tee -a "$logfile"
echo "Removed headers: $removed_headers" | tee -a "$logfile"

# List some examples of removed sequences
if [ $removed_headers -gt 0 ]; then
    echo -e "\nExamples of removed headers:" | tee -a "$logfile"
    grep '^>' "$removed_output" | head -5 | tee -a "$logfile"
fi

# Verify all cleaned headers have 6 semicolons
bad_count=$(grep '^>' "$clean_output" | awk '{if (gsub(/;/, ";", $0) != 6) print}' | wc -l)
if [ $bad_count -eq 0 ]; then
    echo -e "\n✓ All cleaned headers have exactly 6 semicolons." | tee -a "$logfile"
else
    echo -e "\n✗ Warning: $bad_count headers still don't have 6 semicolons!" | tee -a "$logfile"
fi

echo -e "\nOutput files:" | tee -a "$logfile"
echo "Cleaned: $clean_output" | tee -a "$logfile"
echo "Removed: $removed_output" | tee -a "$logfile"
echo "Log: $logfile" | tee -a "$logfile"